package org.robolectric.shadows;

import android.os.Handler;
import android.os.Message;
import android.os.MessageQueue;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

import javax.annotation.Generated;

import org.robolectric.annotation.HiddenApi;
import org.robolectric.annotation.Implementation;
import org.robolectric.annotation.Implements;
import org.robolectric.annotation.RealObject;
import org.robolectric.util.Scheduler;

import static org.robolectric.Shadows.shadowOf;
import static org.robolectric.internal.Shadow.*;
import static org.robolectric.util.ReflectionHelpers.*;
import static org.robolectric.util.ReflectionHelpers.ClassParameter.from;

/**
 * Shadow for MessageQueue that puts {@link Message}s into the scheduler queue instead of sending them to be handled on a
 * separate thread. {@link Message}s that are scheduled to be dispatched can be triggered by calling
 * {@link ShadowLooper#idleMainLooper}.
 * 
 * @see ShadowLooper
 */
@Generated("org.robolectric.shadows.ShadowMessageQueue.java.vm")
@Implements(MessageQueue.class)
public class ShadowMessageQueue {

#if ($api >= 21)
#set($ptrClass = "long")
#set($recycle = "recycleUnchecked")
#else
#set($ptrClass = "int")
#set($recycle = "recycle")
#end

  // Cache fields & methods that are invoked reflectively.
  // Saves having to look them up on every request.
  private static final Field messagesField;
  private static final Method enqueueMethod;
  private static final Method markInUseMethod;
  private static final Method recycleMethod;

  static {
    try {
      messagesField = MessageQueue.class.getDeclaredField("mMessages");
      messagesField.setAccessible(true);
      enqueueMethod = MessageQueue.class.getDeclaredMethod(directMethodName("enqueueMessage"), Message.class, long.class);
      enqueueMethod.setAccessible(true);
      markInUseMethod = Message.class.getDeclaredMethod("markInUse");
      markInUseMethod.setAccessible(true);
      recycleMethod = Message.class.getDeclaredMethod("$recycle");
      recycleMethod.setAccessible(true);
    } catch (ReflectiveOperationException e) {
	  throw new ExceptionInInitializerError(e);
    }
  }

  @RealObject
  private MessageQueue realQueue;

  // Stub out the native peer - scheduling
  // is handled by the Scheduler class which is user-driven
  // rather than automatic.
  @HiddenApi
  @Implementation
  public static $ptrClass nativeInit() {
    return 1;
  }
  
  @HiddenApi
  @Implementation
  public static void nativeDestroy($ptrClass ptr) {}
  
  @HiddenApi
  @Implementation
  public static void nativePollOnce($ptrClass ptr, int timeoutMillis) {
    throw new AssertionError("Should not be called");
  }

  @HiddenApi
  @Implementation
  public static void nativeWake($ptrClass ptr) {
    throw new AssertionError("Should not be called");    
  }
  
  @HiddenApi
  @Implementation
  public static boolean nativeIsIdling($ptrClass ptr) {
    return false;
  }

  public Message getHead() {
    try {
      return (Message)messagesField.get(realQueue);
    } catch (IllegalAccessException e) {
      // This should never happen
      throw new RuntimeException(e);
    }
  }
  
  public void setHead(Message msg) {
    try {
      messagesField.set(realQueue, msg);
    } catch (IllegalAccessException e) {
      // This should never happen
      throw new RuntimeException(e);
    }
  }

  public void reset() {
    setHead(null);
  }
  
  @Implementation
  public boolean enqueueMessage(final Message msg, long when) {
    final boolean retval = callInstanceMethod(realQueue, enqueueMethod, msg, when);
    if (retval) {
      final Scheduler scheduler = shadowOf(msg.getTarget().getLooper()).getScheduler();
      final Runnable callback = new Runnable() {
        @Override
        public void run() {
          synchronized (realQueue) {
            Message m = getHead();
            if (m == null) {
              return;
            }

            Message n = shadowOf(m).getNext();
            if (m == msg) {
              setHead(n);
              dispatchMessage(msg);
              return;
            }

            while (n != null) {
              if (n == msg) {
                n = shadowOf(n).getNext();
                shadowOf(m).setNext(n);
                dispatchMessage(msg);
                return;
              }
              m = n;
              n = shadowOf(m).getNext();
            }
          }
        }
      };
      shadowOf(msg).setScheduledRunnable(callback);
      if (when == 0) {
        scheduler.postAtFrontOfQueue(callback);
      } else {
        scheduler.postDelayed(callback, when - scheduler.getCurrentTime());
      }
    }
    return retval;
  }

  private static void dispatchMessage(Message msg) {
    final Handler target = msg.getTarget();
    
    shadowOf(msg).setNext(null);
    // If target is null it means the message has been removed
    // from the queue prior to being dispatched by the scheduler.
    if (target != null) {
      callInstanceMethod(msg, markInUseMethod);
      target.dispatchMessage(msg);
      callInstanceMethod(msg, recycleMethod);
    }
  }
}
