package org.robolectric.annotation.processing;

import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Filer;
import javax.annotation.processing.Messager;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedOptions;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.TypeParameterElement;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.SourceVersion;
import javax.tools.Diagnostic.Kind;
import javax.tools.FileObject;
import javax.tools.JavaFileObject;
import javax.tools.StandardLocation;

/**
 * Annotation processor entry point for Robolectric annotations.
 */
@SupportedOptions(RoboProcessor.PACKAGE_OPT)
@SupportedAnnotationTypes("org.robolectric.annotation.*")
@SupportedSourceVersion(SourceVersion.RELEASE_7)
public class RoboProcessor extends AbstractProcessor {
  private static final String GEN_CLASS = "Shadows";
  static final String PACKAGE_OPT = "org.robolectric.annotation.processing.shadowPackage";

  private RoboModel model;
  private Messager messager;
  private String shadowPackage;
  private Map<String, String> options;
  private boolean generated = false;
  private Map<TypeElement, Validator> elementValidators = new HashMap<>(13);

  /**
   * Default constructor.
   */
  public RoboProcessor() {
  }

  /**
   * Constructor to use for testing passing options in. Only
   * necessary until compile-testing supports passing options
   * in.
   *
   * @param options simulated options that would ordinarily
   *                be passed in the {@link ProcessingEnvironment}.
   */
  RoboProcessor(Map<String, String> options) {
    processOptions(options);
  }

  @Override
  public void init(ProcessingEnvironment env) {
    super.init(env);
    processOptions(env.getOptions());
    model = new RoboModel(env.getElementUtils(), env.getTypeUtils());
    messager = processingEnv.getMessager();
    messager.printMessage(Kind.NOTE, "Initialising Robolectric annotation processor");
    addValidator(new ImplementationValidator(model, env));
    addValidator(new ImplementsValidator(model, env));
    addValidator(new RealObjectValidator(model, env));
    addValidator(new ResetterValidator(model, env));
  }

  @Override
  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
    for (TypeElement annotation : annotations) {
      Validator validator = elementValidators.get(annotation);
      if (validator != null) {
        for (Element elem : roundEnv.getElementsAnnotatedWith(annotation)) {
          validator.visit(elem, elem.getEnclosingElement());
        }
      }
    }

    if (!generated && shadowPackage != null) {
      model.prepare();
      render();
      generated = true;
    }
    return true;
  }

  private void render() {
    final String fullyQualifiedClassName = shadowPackage + '.' + GEN_CLASS;
    generateShadowClass(processingEnv.getFiler(), fullyQualifiedClassName);
    generateServiceLoaderMetadata(processingEnv.getFiler(), fullyQualifiedClassName);
  }

  private void generateShadowClass(Filer filer, String shadowClassName) {
    messager.printMessage(Kind.NOTE, "Generating output file: " + shadowClassName);

    // TODO: Because this was fairly simple to begin with I haven't
    // included a templating engine like Velocity but simply used
    // raw print() statements, in an effort to reduce the number of
    // dependencies that RAP has. However, if it gets too complicated
    // then using Velocity might be a good idea.
    PrintWriter writer = null;
    try {
      JavaFileObject jfo = filer.createSourceFile(shadowClassName);
      writer = new PrintWriter(jfo.openWriter());
      writer.print("package " + shadowPackage + ";\n");
      for (String name : model.getImports()) {
        writer.println("import " + name + ';');
      }
      writer.println();
      writer.println("/**");
      writer.println(" * Shadow mapper. Automatically generated by the Robolectric Annotation Processor.");
      writer.println(" */");
      writer.println("@Generated(\"" + RoboProcessor.class.getCanonicalName() + "\")");
      writer.println("@SuppressWarnings({\"unchecked\",\"deprecation\"})");
      writer.println("public class " + GEN_CLASS + " implements ShadowProvider {");
      writer.println();
      writer.print("  public static final Class<?>[] DEFAULT_SHADOW_CLASSES = {");
      boolean firstIteration = true;
      for (TypeElement shadow : model.getVisibleShadowTypes().keySet()) {
        if (firstIteration) {
          firstIteration = false;
        } else {
          writer.print(",");
        }
        writer.print("\n    " + model.getReferentFor(shadow) + ".class");
      }
      writer.println("\n  };\n");
      for (Entry<TypeElement, TypeElement> entry : model.getShadowOfMap().entrySet()) {
        final TypeElement actualType = entry.getValue();
        if (!actualType.getModifiers().contains(Modifier.PUBLIC)) {
          continue;
        }
        int paramCount = 0;
        StringBuilder paramDef = new StringBuilder("<");
        StringBuilder paramUse = new StringBuilder("<");
        for (TypeParameterElement typeParam : entry.getValue().getTypeParameters()) {
          if (paramCount > 0) {
            paramDef.append(',');
            paramUse.append(',');
          }
          boolean first = true;
          paramDef.append(typeParam);
          paramUse.append(typeParam);
          for (TypeMirror bound : model.getExplicitBounds(typeParam)) {
            if (first) {
              paramDef.append(" extends ");
              first = false;
            } else {
              paramDef.append(" & ");
            }
            paramDef.append(model.getReferentFor(bound));
          }
          paramCount++;
        }
        String paramDefStr = "";
        String paramUseStr = "";
        if (paramCount > 0) {
          paramDefStr = paramDef.append("> ").toString();
          paramUseStr = paramUse.append('>').toString();
        }
        final String actual = model.getReferentFor(actualType) + paramUseStr;
        final String shadow = model.getReferentFor(entry.getKey()) + paramUseStr;
        writer.println("  public static " + paramDefStr + shadow + " shadowOf(" + actual + " actual) {"); 
        writer.println("    return (" + shadow + ") ShadowExtractor.extract(actual);");
        writer.println("  }");
        writer.println();
      }
      writer.println("  public void reset() {");
      for (Entry<TypeElement, ExecutableElement> entry : model.getResetters()) {
        writer.println("    " + model.getReferentFor(entry.getKey()) + "." + entry.getValue().getSimpleName() + "();");
      }
      writer.println("  }");

      writer.println('}');
    } catch (IOException e) {
      processingEnv.getMessager().printMessage(Kind.ERROR, "Failed to write shadow class file: " + e);
      throw new RuntimeException(e);

    } finally {
      if (writer != null) {
        writer.close();
      }
    }
  }

  private void generateServiceLoaderMetadata(Filer filer, String shadowClassName) {
    String fileName = "org.robolectric.util.ShadowProvider";
    processingEnv.getMessager().printMessage(Kind.NOTE, "Writing META-INF/services/" + fileName);

    try {
      FileObject file = filer.createResource(StandardLocation.CLASS_OUTPUT, "", "META-INF/services/" + fileName);
      PrintWriter pw = new PrintWriter(new OutputStreamWriter(file.openOutputStream(), "UTF-8"));
      pw.println(shadowClassName);
      pw.close();
    } catch (IOException e) {
      processingEnv.getMessager().printMessage(Kind.ERROR, "Failed to write service loader metadata file: " + e);
      throw new RuntimeException(e);
    }
  }

  private void addValidator(Validator v) {
    elementValidators.put(v.annotationType, v);
  }

  private void processOptions(Map<String, String> options) {
    if (this.options == null) {
      this.options = options;
      shadowPackage = options.get(PACKAGE_OPT);
    }
  }
}
